# CP 2: Organizador de Dados em Lista Ligada

## Enunciado

**Voc√™ foi contratado para implementar um sistema de organiza√ß√£o de
grandes volumes de dados representados como n√∫meros inteiros.
Esses dados s√£o armazenados em uma lista ligada (n√£o em arrays) e
precisam ser ordenados de acordo com dois crit√©rios:**
___ 
**1. Crit√©rio 1 (Prim√°rio): Se os n√∫meros forem positivos, use Merge Sort.**

**2. Crit√©rio 2 (Secund√°rio): Se os n√∫meros forem negativos, use Radix Sort adaptado para negativos (considere que o Radix padr√£o s√≥ lida com n√∫meros positivos, 
ent√£o ser√° necess√°rio adaptar ou inverter os sinais temporariamente).**
___
### Al√©m disso, ao final da ordena√ß√£o, o sistema deve:
- Imprimir a lista ligada ordenada completa (com positivos e
negativos juntos, mantendo os negativos antes dos positivos);
- Exibir a complexidade te√≥rica de tempo de cada algoritmo usado;
- Medir e exibir o tempo real de execu√ß√£o de cada algoritmo
separadamente.


___

# üìù	Explicando o c√≥digo

### Classe Node (N√≥)
- Fun√ß√£o do C√≥digo:
     - **self.data = data**,Armazena o valor (dado) que o n√≥ cont√©m.
Pode ser qualquer tipo de dado (inteiro, string, objeto, etc.).
     - **self.next = None**
Inicializa o ponteiro/refer√™ncia para o pr√≥ximo n√≥ da lista ligada.
Por padr√£o, um novo n√≥ √© criado sem conex√£o (None significa "n√£o aponta para nada").
Quando inserimos um novo n√≥ na lista, next √© ajustado para apontar para o pr√≥ximo elemento.

```python
class Node:
    def __init__(self, data):
        self.data = data # Armazena o valor do n√≥
        self.next = None # Refer√™ncia para o pr√≥ximo n√≥ (inicialmente None)
```
- Fun√ß√£o do C√≥digo:
  - **def __init__(self):** √â o construtor da classe, chamado automaticamente quando um objeto LinkedList √© criado.

  - **self.head = None** Inicializa o atributo head (cabe√ßa da lista) como None, indicando que a lista est√° vazia no momento da cria√ß√£o.
head ser√° o primeiro n√≥ da lista. Se head √© None, a lista n√£o tem elementos.


```python
class LinkedList:
    def __init__(self):
        self.head = None # Inicializa a lista vazia
```

```python
def append(self, data):
    # Cria um novo n√≥ com o dado fornecido
    new_node = Node(data)
    #  Se a lista est√° vazia, o novo n√≥ se torna a cabe√ßa (head)
    if not self.head:
        self.head = new_node
        return
    # Caso contr√°rio, percorre a lista at√© o √∫ltimo n√≥
    last = self.head
    while last.next:
        last = last.next
    # Conecta o novo n√≥ ao √∫ltimo n√≥ encontrado
    last.next = new_node    
```